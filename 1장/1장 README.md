# 알고리즘이란 무엇인가??

### Introduction

알고리즘이란 기법에 따라서 문제를 푸는 독특한 단계별 절차이다. 여기서 기법이란 문제의 해답을 찾는 해결법이나 방법론을 의미한다.

예를 들면, 우리는 '홍길동'이라는 이름을 전화번호부에서 찾기 위해서 처음부터 찾기도 한다. 
아니라면 'ㅎ'이 있는 곳으로 이동하여 전화번호부를 편다. 너무 뒤로 갔다면 앞으로 가고 '홍길동'에 도달하기 이전까지 앞뒤로 움직인다. 
첫번째 방법은 순차검색, 두번째는 이분검색이라고 부른다.
이렇게 우리는 새로운 문제에 대해 다양한 방법으로 결과를 도출한다.

다양한 방법중에서 Time과 Space를 가장 효율적으로 사용하는지 또한 잘 알아두어야 한다.

### 1.1 알고리즘
---
#### "문제", "해답", "알고리즘"이라는 단어에 대해서 확실하게 정의하겠다.
**문제**란 해답을 찾으려고 물어보는 질문이다. 
    
    * 문제 예시
    1. n개의 수로 구성된 리스트 S를 오름차순으로 정렬하시오.
    2. 어떤 수 x가 n개의 수의 리스트 S에 있는지 알아보시오. x가 리스트 S안에 있다면 'O', 없다면 'X'이다. 
        
        1) 문제에서 값이 지정되어있지 않은 n개의 리스트 S와 어떤 수 x를 우리는 그 문제의 파라미터라고 한다.
        
        2) 파라미터에 지정할 값을 문제의 입력사례(instance)라고 하고, 
           특정 입력사례에 대한 해답(Solution)이란 입력사례를 지정하여 질문한 문제의 해답이다. 
	
    3. 문제 2에 입력사례를 S = [10, 7, 11, 5, 13, 8] x = 5 라고 한다면 해답은 "O"이다.
        
        1) 우리는 모든 인수에 대해서 해답을 찾아주는 일반적인 단계별 절차를 명시해야한다. 
           이러한 단계별 절차가 바로 알고리즘이고, "문제는 알고리즘으로 푼다"라고 한다.
    4. 문제 2의 알고리즘을 정의하면 다음과 같다.
        1) S의 첫째 원소에서 시작하여 x를 찾을 때까지 각 원소를 차례로 x와 비교한다. 만약 x를 찾으면 'O', 못 찾는다면 'X'라고 한다.
   
### 1.2 효율적인 알고리즘 개발의 중요성
--- 
#### 1.2.1 순차검색 대 이분검색
정렬된 리스트의 순차검색과 이분검색 알고리즘의 작업 양은 N개의 리스트가 있다면 최대로 작업할시에 순차검색은 N번, 이분 검색은 ![equation](https://latex.codecogs.com/gif.latex?log_2&space;N)의 복잡도를 가지게 된다. 이분검색은 한번에 오직 1개의 값을 비교할뿐 나머지 값들은 무시하기 때문이다. 리스트가 커질수록 아래의 표와 같이 차이가 증가함을 알수있다.
|리스트의 크기|순차검색 비교 횟수|이분검색 비교 횟수|
|------|---|---|
|128|128|8|
|1,024|1,024|11|
|1,048,576|1,048,576|21|
|4,274,967,296|4,274,967,296|33|

분할정복법을 공부할 때 다시 이분검색을 다루게 된다. 그때에는 위처럼 2의 배수가 아니라 다른 숫자들도 제약없이 사용하게 될 것이다. 검색하는 문제의 예로만 봐서는 향상된 알고리즘을 설계한다는 일에 대한 중요성이 크게 부각되지 않을지도 모르지만, 우리의 시간이 한정되었을 떄는 그 중요성이 부각될 것이다.

#### 1.2.2. 피보나치 수열
피보나치 수열은 대표적인 재귀 알고리즘으로 다음과 같이 정의된다. 
>![equation](https://latex.codecogs.com/gif.latex?f_0&space;=&space;0)

>![equation](https://latex.codecogs.com/gif.latex?f_1&space;=&space;1)

>![equation](https://latex.codecogs.com/gif.latex?f_n&space;=&space;f_{n-1}&space;&plus;&space;f_{n-2})  (n>1인 경우)

알고리즘으로 나타내면 다음과 같다.

```cpp
int fib( int n )
{
	if( n <= 1 )
		return n;
	else
		return fib(n-1) + fib(n-2);
}
```

하지만 위 알고리즘은 재귀 트리로 나타낼시에는 매우 비효율적이다. 만약에 fib(5)를 부를려면 우리는 fib(4), fib(3)을 호출하고 호출된 2개의 함수가 다시 2개의 fib함수를 호출하기 때문에 가짓수는 다음 표와 같이 증가하게 된다.
|n|계산하는 항의 갯수|
|------|-----|
|1|1|
|2|3|
|3|5|
|4|9|
|5|15|
|6|25|
|7|41|

위의 알고리즘의 맹점은 같은 계산을 반복하는 것이다. 그 맹점을 보완한 알고리즘을 소개하겠다.
```cpp
int fib2(int n)
{
	index i;
	int f[n];
	f[0] = 0;
	if(n>0) {
		f[1] =1;
		for(i = 2; i<=n; i++)
			f[i] = f[i-1] +f[i-2]
	}
	return f[n];
```
아래는 두 알고리즘의 실행시간을 비교한 표이다.
|n|1번 알고리즘|2번 알고리즘|
|---|---|---|
|40|41ns|1048us|
|60|61ns|1s|
|80|81ns|18min|
|100|101ns|13days|
|120|121ns|36years|
|160|161ns|38000000years|

2번째 알고리즘은 피보나치 항의 계산 시간 증가가 linear하지만, 1번째 알고리즘의 경우에는 exponetial하게 증가하면서 큰 차리를 보인다.
1번째 알고리즘은 **분할정복 알고리즘**으로 어떤 부류의 문제에 대해서는 매우 효율적인 알고리즘을 이끌어 내지만 이와 같이 비효율 적인 알고리즘이 나오기도 한다.
2번쨰 알고리즘은 **동적 계획법**의 전형적인 사례로서 우리는 두가지 방법중에서 좋은 방법을 선택하는 것이 매우 중요할 것이다.

### 1.3알고리즘의 분석
---

### 1.4 차수
---


