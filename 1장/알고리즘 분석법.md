# 알고리즘 분석
---
설계한 알고리즘으로 문제를 얼마나 효율적으로 풀 수 있는지 알아보려면 알고리즘을 분석해야 한다. 그러기 위해서 알고리즘 분석에 사용하는 용어와 표준 분석방법에 대해서 제대로 공부해야만 한다.
앞으로 사용할 용어와 표준 분석방법에 대해서 공부하겠다.

## 시간복잡도 분석
알고리즘의 효율성을 분석할 때, CPU에서의 실제 작동시간을 재지 않는다. 특정 컴퓨터에 따라서 달라질 수도 있는 것이다. 실행하는 명령문의 개수를 세지도 않는다. 왜냐하면 구현하는 언어에 따라서, 
프로그래머가 작성하는 방식에 따라서 명령문의 개수가 달라질 수 있기 떄문이다. 하지만 우리는 순차검색보다는 이분검색이 훨씬더 효율적이라는 것을 알고 있다. n이 배열 원소의 개수일 때, 몇몇 n값을
선택하여 두 알고리즘을 실행할 때 비교 횟수의 차이를 보고 알 수 있었다. 우리는 이런 비교연산을 단위연산이라하고 이것에 따라서 실행시간은 비례할 것이다.
이렇게 우리는 단위연산의 수행횟수를 입력의 크기에 대한 함수로 구하여 알고리즘의 효율성을 분석한다.

보통 알고리즘의 입력크기를 재기는 쉽다. 예를 들면, 앞에서 공부한 알고리즘, 순차 검색, 배열의 수 더하기, 교환정렬, 이분검색는 배열의 크기가 곧 입력크기일 것이다. 그리고 행렬곱셈은 행과
열의 곱이 입력크기가 될 것이다. 그리고 알고리즘에 따라서는 그래프가 사용된다면 마디와 이음선의 개수로 총 2가지 입력크기를 사용할 수도 있을 것이다. 그렇지만, 피보나치 항 구하기 같은 경우에는 
n이 입력이지만, 실제 입력크기는 n이 아니라 n을 이진수로 바꾼 비트의 갯수가 더욱 어울릴 것이다.

그렇게 알고리즘의 **시간복잡도 분석**은 입력크기를 기준으로 단위연산을 몇 번 수행하는지 구하는 것이다. 구현 방식의 세부사항은 고려하지 않지만 단위연산은 최대한 효율적으로 구현한다고 가정하고
분석해도 무방할 것이다.

단위연산을 선택하는 전천후 규칙은 없다. 주로 경험에 의한 판단에 따르는 편이다. 제어구조를 구성하는 명령문은 보통 단위연산으로 취급하지않는다.
예를 들어, **while**문의 경우에는 루프의 제어를 위해서 사용하는 인덱스 증가 및 비교문은 단위연산으로 취급하지 않겠다는 것이다. 우리는 컴퓨터와는 독립적으로 분석을 하기에 그런 극단적인 경우는
제외하겠다.

때로는 두 개의 다른 단위연산을 고려해야 하는 경우도 있다. 예를 들어, 키를 비교하여 정렬하는 알고리즘에서 비교문과 지정문을 개별 단위연산으로 취급한다는 것이다.
우리가 비교를 할때마다 지정을 하지 않기 떄문에 둘의 횟수가 다르기에 우리는 효율성을 면밀히 살피기 위해서 구분한 것이다.
## 일정 시간복잡도
입력의 값에 상관없이 항상 단위연산의 실행 횟수가 일정하다면 우리는 알고리즘의 일정 시간복잡도라고 한다.
---
 ### 1. 배열의 원소를 모두 더하기
> 단위연산 : 배열의 원소를 sum에 더함

> 입력크기 : 배열 원속의 개수

> 배열에 있는 원소의 값에 상관없이 for루프를 n번 실행한다. 그러므로 T(n) = n이다.

 ### 2. 교환정렬
> 단위연산 : S[j]와 S[i]의 비교

> 입력크기 : 정렬할 원소의 개수, n

>> for-j루프를 몇 번 실행하는지 세어야한다. 주어진 n에 대해서 for-i 루프를 실행하는 횟수는 항상 n-1이다. 첫째 for-i루프를 실행할 때 for-j 루프를 실행하는 횟수는 n-1, 다음 for-i루프를 실행
할 때 for-j를 실행하는 횟수는 n-2가 될 것이고 마지막에는 1이 될 것이다. 이렇게 더한 값은 
![equation](https://latex.codecogs.com/gif.latex?T(n)&space;=&space;\frac{(n-1)(n)}{2}) 일 것이다.

### 3. 행렬곱셈
> 단위연산 : 가장 안쪽 for 루프에 있는 곱셈

> 입력크기 : 행과 열의 개수, n

> ![equation](https://latex.codecogs.com/gif.latex?T(n)&space;=&space;n^3) 
---

## 최악 시간복잡도
크기가 아무리 n으로 일정하다고 해도 단위연산을 실행하는 횟수는 다를 것이다. 그렇기에 우리는 단위연산을 수행하는 최대 횟수 W(n)을 정해서 최악 시간복잡도라 하겠다.

### 순차검색(최악 시간복잡도 분석)
> 단위연산 : 배열 원소와 x와의 비교

> 입력크기 : 배열 원소의 개수, n

> W(n) = n

## 평균 시간복잡도
최악의 경우는 최대 시간을 알 수 있지만, 평균적으로 얼마나 실행하는지 측정하면 더 일리가 있는 경우가 있다. 

A(n)을 계산하려면 n개의 입력에 확률을 각각 부여해야한다. 순차검색에서 x가 배열 안에 있고, 이중 어디에 위치할 확률은 똑같다고 가정한다.

### 순차겁색(평균 시간복잡도 분석)
> 단위연산 : 배열 원소와 x와의 비교

> 입력크기 : 배열 원소의 개수, n

> 만약에 x가 배열에 없을 확률이 1-p이고 있을 확률이 p라면 
> ![equation](https://latex.codecogs.com/gif.latex?A(n)&space;=&space;\sum_{k=1}^{n}(k*\frac{p}{n})&space;&plus;&space;n(1-p)&space;=&space;\frac{p}{n}&space;*&space;\frac{n(n&plus;1)}{2}&space;&plus;&space;n(1-p)&space;=&space;n(1-\frac{p}{2})&space;&plus;&space;\frac{p}{2}) 일 것이다.

> 즉 p=1/2이면 A(n) = 3n/4 + 1/4가 될 것이다. 이것은 배열의 3/4정도가 평균적으로 검색될 것이라는 것이다.

## 최선 시간 복잡도
단위연산을 실행하는 최소 횟수를 구하는 것이다.
### 순차검색(최선 시간복잡도 분석)
> 단위연산 : 배열 원소와 x와의 비교

> 입력크기 : 배열 원소의 개수, n

> B(n) = 1

## 결론
일정 시간복잡도를 구할 수 없는 알고리즘에 대하여 우리는 최선보다는 평균 혹은 최악을 채택한다. 평균의 경우 분석은 다른 입력을 여러번 사용할 때 알고리즘을 실행하는데 평균적으로 걸리는 시간을
알려주기 때문에 유용하게 많이 쓴다. 그리고 가능한 모든 조합으로 만든 입력을 모두 정렬하는 경우 속도를 재는 좋은 척도가 될 수 있다. 속도가 느린 정렬 알고리즘이라도 평균적으로 시간이 좋게 나오는 경우 때로는 쓸 만하기도 하다. 2장에서 살펴볼 빠른 정렬이라고 하는 알고리즘이 바로 그런데, 가장 널리 쓰여지고 있다. 그리고 핵발전소 감시시스템 같은 경우에는 평균보다는 상한 값을 알 수 있는최악 시간 복잡도가 필요할 것이다.
